import { GoogleGenerativeAI } from "@google/generative-ai";

/**
 * Service to interact with the Gemini API for text generation using the official SDK.
 */

/**
 * Generate AI content with customizable options
 * @param {Object} options - Configuration options for AI generation
 * @param {string} options.prompt - The user prompt/input
 * @param {string} [options.systemPrompt] - System prompt to set context/behavior
 * @param {string} [options.model] - Model to use (default: gemini-2.5-flash-preview-05-20)
 * @param {number} [options.temperature] - Creativity level (0-1, default: 0.7)
 * @param {number} [options.maxTokens] - Maximum response length
 * @param {Object} [options.generationConfig] - Additional generation configuration
 * @returns {Promise<string>} Generated text response
 */
export const generateFromAI = async ({
  prompt,
  systemPrompt = null,
  model = "gemini-1.5-pro",
  temperature = 0.7,
  maxTokens = null,
  generationConfig = {},
}) => {
  console.log("ü§ñ AI Service - Starting generation with:", {
    prompt: prompt?.substring(0, 100) + (prompt?.length > 100 ? "..." : ""),
    systemPrompt:
      systemPrompt?.substring(0, 100) +
      (systemPrompt?.length > 100 ? "..." : ""),
    model,
    temperature,
    maxTokens,
  });

  // Get the API key from environment variables
  const apiKey = import.meta.env.VITE_GEMINI_API_KEY;

  if (!apiKey) {
    console.error("‚ùå VITE_GEMINI_API_KEY is not set in environment variables");
    throw new Error(
      "API key is not configured. Please contact support to set up AI services."
    );
  }

  console.log("‚úÖ API key found, creating GoogleGenerativeAI instance...");

  // Create a new GoogleGenerativeAI instance.
  const genAI = new GoogleGenerativeAI(apiKey);

  // Prepare generation configuration
  const config = {
    temperature,
    ...generationConfig,
  };

  if (maxTokens) {
    config.maxOutputTokens = maxTokens;
  }

  //   console.log("üîß Generation config:", config);

  // Get the generative model to use.
  const generativeModel = genAI.getGenerativeModel({
    model,
    generationConfig: config,
    systemInstruction: systemPrompt || undefined,
  });

  //   console.log("üì° Making API call to Gemini...");

  try {
    // Call the generateContent method to get a response.
    const result = await generativeModel.generateContent(prompt);

    console.log("üì• Full API result:", JSON.stringify(result, null, 2));

    // Extract the text - handle different response structures
    let text = null;

    // Try the standard SDK response method first
    try {
      const response = await result.response;
      text = response.text();
      console.log("‚úÖ Using response.text() method:", text);
    } catch (responseError) {
      console.log("‚ö†Ô∏è response.text() failed, trying direct access...");

      // Fallback to direct access
      if (result.response?.candidates?.[0]?.content?.parts?.[0]?.text) {
        text = result.response.candidates[0].content.parts[0].text;
        console.log("‚úÖ Using result.response.candidates direct access:", text);
      } else if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
        text = result.candidates[0].content.parts[0].text;
        console.log("‚úÖ Using result.candidates direct access:", text);
      }
    }

    console.log("‚úÖ Final text extraction:", {
      text: text?.substring(0, 200) + (text?.length > 200 ? "..." : ""),
      length: text?.length,
      fullText: text,
    });

    if (!text || text.trim() === "") {
      console.error("‚ùå No text found in response");
      throw new Error(
        "No content was generated by the AI service. Please try again."
      );
    }

    return text.trim();
  } catch (error) {
    console.error("‚ùå Error calling the Gemini API:", error);
    console.error("‚ùå Error details:", {
      message: error.message,
      stack: error.stack,
      name: error.name,
    });

    // Re-throw the error with more specific messaging
    if (error.message?.includes("API key")) {
      throw new Error(
        "AI service configuration error. Please contact support."
      );
    } else if (
      error.message?.includes("network") ||
      error.message?.includes("fetch")
    ) {
      throw new Error(
        "Network connection error. Please check your internet connection and try again."
      );
    } else if (
      error.message?.includes("quota") ||
      error.message?.includes("limit")
    ) {
      throw new Error(
        "AI service temporarily unavailable. Please try again later."
      );
    } else {
      throw new Error(
        error.message ||
          "An unexpected error occurred with the AI service. Please try again."
      );
    }
  }
};

/**
 * Convenience function for simple text generation (backward compatibility)
 * @param {string} prompt - The prompt to generate content for
 * @returns {Promise<string>} Generated text response
 */
export const generateSimpleAI = async (prompt) => {
  return generateFromAI({ prompt });
};

/**
 * Generate AI content for survey-related tasks
 * @param {string} prompt - The user prompt
 * @param {string} [context] - Additional context about the survey
 * @returns {Promise<string>} Generated text response
 */
export const generateSurveyContent = async (prompt, context = "") => {
  const systemPrompt = `You are an AI assistant specialized in creating and improving survey content. 
You help users create clear, unbiased, and effective survey questions and descriptions.
Focus on clarity, neutrality, and user engagement.
${context ? `Additional context: ${context}` : ""}`;

  return generateFromAI({
    prompt,
    systemPrompt,
    temperature: 0.6,
  });
};

/**
 * Generate AI content for feedback analysis
 * @param {string} prompt - The user prompt
 * @param {string} [feedbackType] - Type of feedback being analyzed
 * @returns {Promise<string>} Generated text response
 */
export const generateFeedbackAnalysis = async (prompt, feedbackType = "") => {
  const systemPrompt = `You are an AI assistant specialized in analyzing feedback and survey responses.
You help users understand patterns, sentiments, and insights from collected feedback.
Provide objective, data-driven analysis with actionable recommendations.
${feedbackType ? `Feedback type: ${feedbackType}` : ""}`;

  return generateFromAI({
    prompt,
    systemPrompt,
    temperature: 0.3,
  });
};

/**
 * Generate a complete survey structure based on user description
 * @param {string} description - Description of the survey the user wants to create
 * @returns {Promise<Object>} Generated survey structure with title, description, and questions
 */
export const generateSurvey = async (description) => {
  console.log("üîç AI Survey Generation - Starting with description:", description);
  
  const systemPrompt = `You are an AI assistant specialized in creating complete survey structures.
Based on the user's description, generate a comprehensive survey with:
1. A clear, engaging title
2. A helpful description for survey takers
3. A set of relevant questions (3-8 questions)

Return ONLY a valid JSON object with this exact structure:
{
  "title": "Survey Title",
  "description": "Brief description of the survey purpose",
  "questions": [
    {
      "type": "TEXT|LONG_TEXT|RATING|MULTIPLE_CHOICE",
      "text": "Question text",
      "options": ["option1", "option2"] // Only for MULTIPLE_CHOICE
      "ratingScale": 5, // Only for RATING (always use 5)
      "minLabel": "Poor", // Only for RATING
      "maxLabel": "Excellent", // Only for RATING
      "required": true
    }
  ]
}

Question types:
- TEXT: Short text responses
- LONG_TEXT: Detailed text responses  
- RATING: 0-5 numerical scale (always use scale 5)
- MULTIPLE_CHOICE: Select from 2-6 options

Make questions clear, unbiased, and relevant to the survey purpose.`;

  try {
    console.log("üì§ Sending request to AI with system prompt");
    
    const response = await generateFromAI({
      prompt: `Create a survey for: ${description}`,
      systemPrompt,
      temperature: 0.7,
      model: "gemini-1.5-pro"
    });

    console.log("üì• Raw AI response:", response);

    // Try to parse the JSON response
    let surveyData;
    try {
      // Clean the response - remove any markdown code blocks
      const cleanResponse = response.replace(/```json\s*/gi, '').replace(/```\s*/gi, '').trim();
      console.log("üßπ Cleaned response:", cleanResponse);
      
      surveyData = JSON.parse(cleanResponse);
      console.log("‚úÖ Parsed survey data:", surveyData);
    } catch (parseError) {
      console.error("‚ùå Failed to parse AI response as JSON:", parseError);
      console.error("Raw response was:", response);
      throw new Error("AI returned invalid JSON format");
    }

    // Validate the structure
    if (!surveyData.title || !surveyData.questions || !Array.isArray(surveyData.questions)) {
      console.error("‚ùå Invalid survey structure:", surveyData);
      throw new Error("AI returned incomplete survey structure");
    }

    // Validate questions
    for (let i = 0; i < surveyData.questions.length; i++) {
      const question = surveyData.questions[i];
      if (!question.type || !question.text) {
        console.error(`‚ùå Invalid question at index ${i}:`, question);
        throw new Error(`Question ${i + 1} is missing required fields`);
      }
      
      // Validate question types
      const validTypes = ['TEXT', 'LONG_TEXT', 'RATING', 'MULTIPLE_CHOICE'];
      if (!validTypes.includes(question.type)) {
        console.error(`‚ùå Invalid question type at index ${i}: ${question.type}`);
        question.type = 'TEXT'; // Default fallback
      }
      
      // Ensure MULTIPLE_CHOICE has options
      if (question.type === 'MULTIPLE_CHOICE' && (!question.options || !Array.isArray(question.options))) {
        console.error(`‚ùå MULTIPLE_CHOICE question missing options at index ${i}`);
        question.options = ['Option 1', 'Option 2', 'Option 3'];
      }
    }

    console.log("‚úÖ Survey generation successful:", {
      title: surveyData.title,
      questionCount: surveyData.questions.length,
      questionTypes: surveyData.questions.map(q => q.type)
    });

    return surveyData;

  } catch (error) {
    console.error("‚ùå Survey generation failed:", error);
    throw new Error(`Failed to generate survey: ${error.message}`);
  }
};
